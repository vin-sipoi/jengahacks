// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { requestLogger } from '@/lib/requestLogger';

/**
 * Development-only request/response logging
 * 
 * In development mode, all Supabase operations are automatically logged:
 * - Database queries (SELECT, INSERT, UPDATE, DELETE)
 * - Storage operations (upload, download, signed URLs, etc.)
 * - Edge Function invocations
 * - RPC function calls
 * 
 * Logs include request data, response data, errors, and duration.
 * Sensitive data is automatically redacted.
 * 
 * Access logs in browser console: `window.requestLogger`
 */

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Validate environment variables
if (!SUPABASE_URL) {
  throw new Error('Missing VITE_SUPABASE_URL environment variable');
}

if (!SUPABASE_PUBLISHABLE_KEY) {
  throw new Error('Missing VITE_SUPABASE_PUBLISHABLE_KEY environment variable');
}

// Validate URL format
try {
  new URL(SUPABASE_URL);
} catch {
  throw new Error('Invalid VITE_SUPABASE_URL format');
}

// Create base client
const baseClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// Wrap Supabase client methods for logging (development only)
const isDevelopment = import.meta.env.DEV || import.meta.env.MODE === 'development';

const supabase = isDevelopment ? {
  ...baseClient,
  
  // Wrap from() for database queries
  // Use a proxy to intercept all query builder methods
  from: ((table: keyof Database['public']['Tables']) => {
    const queryBuilder = baseClient.from(table);
    
    // Create a proxy that wraps promise-returning methods
    return new Proxy(queryBuilder, {
      get(target, prop) {
        const original = target[prop as keyof typeof target];
        
        // Only wrap methods that return promises (select, insert, update, delete)
        if (typeof original === 'function' && ['select', 'insert', 'update', 'delete'].includes(prop as string)) {
          return function (this: unknown, ...args: unknown[]) {
            const startTime = performance.now();
            const result = (original as (...args: unknown[]) => Promise<unknown>).apply(target, args);
            
            // Wrap the promise to log request/response
            return result.then(
              (data) => {
                const duration = performance.now() - startTime;
                requestLogger.log({
                  type: 'database',
                  method: (prop as string).toUpperCase(),
                  endpoint: `from('${table}').${prop as string}()`,
                  request: { table, args },
                  response: data,
                  duration: Math.round(duration),
                });
                return data;
              },
              (error) => {
                const duration = performance.now() - startTime;
                requestLogger.log({
                  type: 'database',
                  method: (prop as string).toUpperCase(),
                  endpoint: `from('${table}').${prop as string}()`,
                  request: { table, args },
                  error,
                  duration: Math.round(duration),
                });
                return Promise.reject(error);
              }
            );
          };
        }
        
        // Pass through all other properties/methods
        if (typeof original === 'function') {
          return original.bind(target);
        }
        return original;
      },
    });
  }) as typeof baseClient.from,
  
  // Wrap functions.invoke() for Edge Functions
  functions: {
    ...baseClient.functions,
    invoke: <T = unknown>(functionName: string, options?: { body?: unknown; headers?: Record<string, string> }) => {
      const startTime = performance.now();
      const result = baseClient.functions.invoke<T>(functionName, options);
      
      return result.then(
        async (data) => {
          const duration = performance.now() - startTime;
          requestLogger.log({
            type: 'function',
            method: 'INVOKE',
            endpoint: `functions/${functionName}`,
            request: { functionName, body: options?.body, headers: options?.headers },
            response: data,
            duration: Math.round(duration),
          });
          
          // Track in monitoring system
          try {
            const { monitor } = await import('@/lib/monitoring');
            monitor.trackApiResponseTime(`functions/${functionName}`, Math.round(duration), true);
          } catch {
            // Monitoring not available, ignore
          }
          
          return data;
        },
        async (error) => {
          const duration = performance.now() - startTime;
          requestLogger.log({
            type: 'function',
            method: 'INVOKE',
            endpoint: `functions/${functionName}`,
            request: { functionName, body: options?.body, headers: options?.headers },
            error,
            duration: Math.round(duration),
          });
          
          // Track in monitoring system
          try {
            const { monitor } = await import('@/lib/monitoring');
            monitor.trackApiResponseTime(`functions/${functionName}`, Math.round(duration), false);
            if (error instanceof Error) {
              monitor.trackError(error, { endpoint: `functions/${functionName}` });
            }
          } catch {
            // Monitoring not available, ignore
          }
          
          return Promise.reject(error);
        }
      );
    },
  },
  
  // Wrap rpc() for RPC calls
  rpc: <T = unknown>(fnName: string, args?: Record<string, unknown>) => {
    const startTime = performance.now();
    // @ts-expect-error - Development-only wrapper, type safety handled at runtime
    const result = baseClient.rpc(fnName, args);
    
    return result.then(
      // @ts-expect-error - Development-only wrapper
      (data: T) => {
        const duration = performance.now() - startTime;
        requestLogger.log({
          type: 'rpc',
          method: 'RPC',
          endpoint: `rpc/${fnName}`,
          request: { functionName: fnName, args },
          response: data,
          duration: Math.round(duration),
        });
        return data;
      },
      (error) => {
        const duration = performance.now() - startTime;
        requestLogger.log({
          type: 'rpc',
          method: 'RPC',
          endpoint: `rpc/${fnName}`,
          request: { functionName: fnName, args },
          error,
          duration: Math.round(duration),
        });
        return Promise.reject(error);
      }
    ) as Promise<T>;
  },
  
  // Wrap storage operations
  storage: {
    ...baseClient.storage,
    from: (bucket: string) => {
      const storageBucket = baseClient.storage.from(bucket);
      
      return {
        ...storageBucket,
        upload: (path: string, file: File | Blob | ArrayBuffer, options?: { contentType?: string; upsert?: boolean }) => {
          const startTime = performance.now();
          const result = storageBucket.upload(path, file, options);
          
          return result.then(
            (data) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'UPLOAD',
                endpoint: `storage/${bucket}/${path}`,
                request: { bucket, path, contentType: options?.contentType, upsert: options?.upsert },
                response: data,
                duration: Math.round(duration),
              });
              return data;
            },
            (error) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'UPLOAD',
                endpoint: `storage/${bucket}/${path}`,
                request: { bucket, path, contentType: options?.contentType, upsert: options?.upsert },
                error,
                duration: Math.round(duration),
              });
              return Promise.reject(error);
            }
          );
        },
        
        download: (path: string) => {
          const startTime = performance.now();
          const result = storageBucket.download(path);
          
          return result.then(
            (data) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'DOWNLOAD',
                endpoint: `storage/${bucket}/${path}`,
                request: { bucket, path },
                response: { blob: data.data ? 'Blob' : null, error: data.error },
                duration: Math.round(duration),
              });
              return data;
            },
            (error) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'DOWNLOAD',
                endpoint: `storage/${bucket}/${path}`,
                request: { bucket, path },
                error,
                duration: Math.round(duration),
              });
              return Promise.reject(error);
            }
          );
        },
        
        createSignedUrl: (path: string, expiresIn: number) => {
          const startTime = performance.now();
          const result = storageBucket.createSignedUrl(path, expiresIn);
          
          return result.then(
            (data) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'CREATE_SIGNED_URL',
                endpoint: `storage/${bucket}/${path}`,
                request: { bucket, path, expiresIn },
                response: data,
                duration: Math.round(duration),
              });
              return data;
            },
            (error) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'CREATE_SIGNED_URL',
                endpoint: `storage/${bucket}/${path}`,
                request: { bucket, path, expiresIn },
                error,
                duration: Math.round(duration),
              });
              return Promise.reject(error);
            }
          );
        },
        
        remove: (paths: string[]) => {
          const startTime = performance.now();
          const result = storageBucket.remove(paths);
          
          return result.then(
            (data) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'REMOVE',
                endpoint: `storage/${bucket}`,
                request: { bucket, paths },
                response: data,
                duration: Math.round(duration),
              });
              return data;
            },
            (error) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'REMOVE',
                endpoint: `storage/${bucket}`,
                request: { bucket, paths },
                error,
                duration: Math.round(duration),
              });
              return Promise.reject(error);
            }
          );
        },
        
        list: (path?: string, options?: { limit?: number; offset?: number; sortBy?: { column?: string; order?: 'asc' | 'desc' } }) => {
          const startTime = performance.now();
          const result = storageBucket.list(path, options);
          
          return result.then(
            (data) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'LIST',
                endpoint: `storage/${bucket}${path ? `/${path}` : ''}`,
                request: { bucket, path, options },
                response: data,
                duration: Math.round(duration),
              });
              return data;
            },
            (error) => {
              const duration = performance.now() - startTime;
              requestLogger.log({
                type: 'storage',
                method: 'LIST',
                endpoint: `storage/${bucket}${path ? `/${path}` : ''}`,
                request: { bucket, path, options },
                error,
                duration: Math.round(duration),
              });
              return Promise.reject(error);
            }
          );
        },
      };
    },
  },
  
  // Pass through other properties
  auth: baseClient.auth,
  realtime: baseClient.realtime,
} : baseClient;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export { supabase };
